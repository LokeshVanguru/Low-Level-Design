--->Strategy Pattern is a behavioral design pattern that lets you define a family of algorithms,
put each one in a separate class, and make them interchangeable at runtime.

--->“Choose the behavior at runtime without changing the object.”

--->When we need to select one option or behavior from multiple choices at runtime, we use the Strategy Pattern.”

----------------------------------Without Strategy Pattern:

Too many if-else or switch statements

One class doing too many things

Hard to add new behavior

Violates Open–Closed Principle

-----------------------------------With Strategy Pattern:

Each behavior is isolated

Easy to add new behavior

Cleaner and flexible design

-----Real Applications of strategy pattern

Payment Methods
Travel Selections like bike,bus,car
Sorting Algorithms based on Data Size
Authentication Methods like user+pass,Otp,Biometric

---------------------------------------------------------------------------

Example:

Let's consider a simple payment system where users can pay using different
methods like credit cards or PayPal. Without the Strategy Pattern, you might use
if-else conditions to handle the different payment methods, leading to less
maintainable and flexible code.

-----------------------------------------------------------------------------

WithoutStrategyPattern

----->The PaymentService class has multiple responsibilities (deciding the
payment type and processing it).
----->Adding a new payment method requires modifying the PaymentService
class.
----->The use of if-else conditions can make the code harder to maintain as more
payment types are added.


WithStrategyPattern

With the Strategy Pattern, the logic for each payment type is encapsulated in separate strategy
classes, and the PaymentService (context class) delegates the task of payment processing to one
of these strategies at runtime.